
#' Load a FACETS output rdata file
#'
#' This function loads an Rdata file generated by FACETS (ref)
#' it expects to find an object called 'fit' which contains the information generated by FACETS
#' Depending on the combination of the lcn,tcn values it adds a flag under cnv_flag
#' describing the type of the copy number abberation.
#' FACETS is an Allele-specific copy number analysis (ASCN) tool and open-source software with a broad application
#' to whole genome, whole-exome, as well as targeted panel sequencing platforms. It is a fully integrated stand-alone pipeline that includes sequencing BAM file post-processing, joint segmentation of total- and allele-specific read counts, and integer copy number calls corrected for tumor purity, ploidy and clonal heterogeneity.
#' FACETS provides information about subclones, this information is used for the visualization and comparisons.
#' Because the germline (diploid) segments are marked as 2 CNV for major clone and 1 Copy for minor (just a convention of the tool), we add a column with the percentage of the minor clone, by subtracting the percentage of the major clone from the calculated purity.
#' The columns are:
#'   * ‘chrom’ the chromosome to which the segment belongs;
#' * ‘seg’ the segment number;
#' * ‘num.mark’ the number of SNPs in the segment;
#' * ‘nhet’ the number of SNPs that are deemed heterozygous;
#' * ‘cnlr.median’ the median log-ratio of the segment;
#' * ‘mafR’ the log-odds-ratio summary for the segment;
#' * ‘segclust’ the segment cluster to which segment belongs;
#' * ‘cnlr.median.clust’ the median log-ratio of the segment cluster;
#' * ‘mafR.clust’ the log-odds-ratio summary for the segment cluster;
#' * ‘cf’ the cellular fraction of the segment;
#' * ‘tcn’ the total copy number of the segment;
#' * ‘lcn’ the minor copy number of the segment.
#' The column lcn.cf.em is added to capture the expected abundance of the minor clone.
#' Segments with cf.em == 1 represent a single clone. If the tcn.em is 2 and lcn.em is 1 this is the germline. In all other cases cf.em represents the cellular fraction of the segment
#' Segments with lcn.em=NA segments are tricky due to the sparsity of het SNPs we cant determine lcn unambiguously.
#' @param facets.fn Path to the input file
#' @return A GRanges object with the segments predicted by FACETS
#' @export
parseFACETS_rds=function(facets.fn){
  base::load(facets.fn)
  return(parseFACETS(fit$cncf))
}


#' Load a FACETS output from a tab delimited file
#'
#' This function loads file generated by FACETS (ref)
#' it expects to find a tab delimited file
#' The columns are:
#' * ‘chrom’ the chromosome to which the segment belongs;
#' * ‘seg’ the segment number;
#' * ‘num.mark’ the number of SNPs in the segment;
#' * ‘nhet’ the number of SNPs that are deemed heterozygous;
#' * ‘cnlr.median’ the median log-ratio of the segment;
#' * ‘mafR’ the log-odds-ratio summary for the segment;
#' * ‘segclust’ the segment cluster to which segment belongs;
#' * ‘cnlr.median.clust’ the median log-ratio of the segment cluster;
#' * ‘mafR.clust’ the log-odds-ratio summary for the segment cluster;
#' * ‘cf’ the cellular fraction of the segment;
#' * ‘tcn’ the total copy number of the segment;
#' * ‘lcn’ the minor copy number of the segment.
#' @param facets.fn Path to the input file
#' @return A GRanges object with the segments predicted by FACETS
#' @export
parseFACETS_file=function(facets.fn){
  facets.df=read.table(facets.fn, header=TRUE, sep="\t")
  return(parseFACETS(facets.df))
}


#' Generate a cnv Granges from a dataframe created by FACETS
#'
#' Depending on the combination of the lcn,tcn values it adds a flag under cnv_flag
#' describing the type of the copy number abberation.
#' FACETS is an Allele-specific copy number analysis (ASCN) tool and open-source software with a broad application
#' to whole genome, whole-exome, as well as targeted panel sequencing platforms. It is a fully integrated stand-alone pipeline that includes sequencing BAM file post-processing, joint segmentation of total- and allele-specific read counts, and integer copy number calls corrected for tumor purity, ploidy and clonal heterogeneity.
#' FACETS provides information about subclones, this information is used for the visualization and comparisons.
#' Because the germline (diploid) segments are marked as 2 CNV for major clone and 1 Copy for minor (just a convention of the tool),
#' we add a column with the percentage of the minor clone, by subtracting the percentage of the major clone from the calculated purity.
#' The columns of the dataframe are:
#' * ‘chrom’ the chromosome to which the segment belongs;
#' * ‘seg’ the segment number;
#' * ‘num.mark’ the number of SNPs in the segment;
#' * ‘nhet’ the number of SNPs that are deemed heterozygous;
#' * ‘cnlr.median’ the median log-ratio of the segment;
#' * ‘mafR’ the log-odds-ratio summary for the segment;
#' * ‘segclust’ the segment cluster to which segment belongs;
#' * ‘cnlr.median.clust’ the median log-ratio of the segment cluster;
#' * ‘mafR.clust’ the log-odds-ratio summary for the segment cluster;
#' * ‘cf’ the cellular fraction of the segment;
#' * ‘tcn’ the total copy number of the segment;
#' * ‘lcn’ the minor copy number of the segment.
#' The column lcn.cf.em is added to capture the expected abundance of the minor clone.
#' Segments with cf.em == 1 represent a single clone. If the tcn.em is 2 and lcn.em is 1 this is the germline. In all other cases cf.em represents the cellular fraction of the segment
#' Segments with lcn.em=NA segments are tricky due to the sparsity of het SNPs we cant determine lcn unambiguously.
#' |---------|----------|--------------|
#' |total cn | minor cn |	type         |
#' |---------|----------|--------------|
#' |0        |	0 	    | HOMDEL       |
#' |0        |	NA 	    | HOMDEL       |
#' |1        |	0 	    | HETDEL       |
#' |1        |	NA 	    | HETDEL       |
#' |2        |	0 	    | NEUTLOH      |
#' |2        |	1 	    | NEUT         |
#' |2        |	NA 	    | NEUT/Unknown |
#' |2+       |	0 	    | AMP-LOH      |
#' |2+       |	1+ 	    | AMP          |
#' |2+       |	NA 	    | AMP-[LOH?]   |
#' |---------|----------|--------------|
#'
#' @param facets.df Dataframe with inputfiles
#' @return A GRanges object with the segments predicted by FACETS
#' @export
parseFACETS=function(facets.df){
  facets.df[ which(facets.df$chrom==23),"chrom"]="X"
  facets.gr=GenomicRanges::makeGRangesFromDataFrame( facets.df,
                                                     keep.extra.columns = TRUE,
                                                     ignore.strand = TRUE) %>%
    GenomeInfoDb::sortSeqlevels( ) %>%
    BiocGenerics::sort()
  GenomeInfoDb::seqlevelsStyle(facets.gr)='UCSC'


  # Add the flags

  mcols_new=S4Vectors::mcols( facets.gr ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate( total.allele.copies=tcn.em,
                   major.allele.copies=ifelse( is.na(lcn.em), tcn.em, tcn.em-lcn.em),
                   minor.allele.copies=lcn.em)

  flags=apply(mcols_new, 1, function(K){ cnvFlag(major.cn = K['major.allele.copies'], minor.cn = K['minor.allele.copies'] )})
  mcols_new = mcols_new %>%
    dplyr::mutate( cnv.flag=flags)

  S4Vectors::mcols( facets.gr )=mcols_new

  return(facets.gr)
}

#' Load a ControlFreec _CNV output from a tab delimited file
#' this function can also use a _CNV file with pvalues added by the accompanying script in the controlFreec package.
#' it expects to find a tab delimited file
#' The columns are:
#' * chromosome
#' * start position
#' * end position
#' * copy.number
#' * status
#' * genotype
#' * uncertainty of the assignment
#' * WilcoxonRankSumTestPvalue
#' * KolmogorovSmirnovPvalue
#' Note: at least for v 11.5 it is not possible to understand how subclones are coded in the output files.
#' As a result we only parse the main clone information (i.e no subclones). A related ticket has been
#' opened on GitHub to help understand the C-FREEC outputs (https://github.com/BoevaLab/FREEC/issues/84)
#' @param cfreec.fn input filename with CNV segments,
#'        filterLowUncerntainty if set to TRUE segments with uncertainty equal to -1 will be discarded
#'        pvalThreshold  threshold of pvalues to filter if the pvalues are included in the file
#' @return A GRanges object with the segments predicted by ControlFreec
#' @export
parseCfreec_file=function(cfreec.fn){
  controlfreec=read.table(cfreec.fn,header=FALSE, sep="\t")
  if( controlfreec[1,1]=="chr"){
    colnames(controlfreec)=controlfreec[1,]
    controlfreec=controlfreec[-1,]
  }else{
    colnames(controlfreec)=c( "chr","start" ,"end","copy.number","status","genotype", "uncertainty" )
  }
  return(parseCfreec( controlfreec ))
}

#' Generate a cnv Granges from a dataframe created by ControlFreec (file ending in .CNVs or contains pvalues.)
#' Control-FREEC is a tool for detection of copy-number changes and allelic imbalances (including LOH)
#' using deep-sequencing data. It automatically computes, normalizes, segments copy number and beta allele
#' frequency (BAF) profiles, then calls copy number alterations and LOH. The control (matched normal) sample
#' is optional for whole genome sequencing data but mandatory for whole exome or targeted sequencing data.
#' Control-FREEC up to now (Jan 2021) is the standard tool used in the hCELG and hBMS pipelines for data
#' analysis of WES and WGS datasets.
#' When the genotype is - it means that the progrm did not find any SNPs to decide the correct genotype, and
#' the estimated copy number depends on the logRR
#' The output includes
#' * chromosome
#' * start position
#' * end position
#' * copy.number
#' * status
#' * genotype
#' * uncertainty of the assignment
#' * WilcoxonRankSumTestPvalue
#' * KolmogorovSmirnovPvalue
#' Note: at least for v 11.5 it is not possible to understand how subclones are coded in the output files.
#' As a result we only parse the main clone information (i.e no subclones). A related ticket has been opened on GitHub to help understand the C-FREEC outputs (https://github.com/BoevaLab/FREEC/issues/84)
#' |---------|----------|--------------|
#' |total cn | minor cn |	type         |
#' |---------|----------|--------------|
#' |0        |	0 	    | HOMDEL       |
#' |0        |	NA 	    | HOMDEL       |
#' |1        |	0 	    | HETDEL       |
#' |1        |	NA 	    | HETDEL       |
#' |2        |	0 	    | NEUTLOH      |
#' |2        |	1 	    | NEUT         |
#' |2        |	NA 	    | NEUT/Unknown |
#' |2+       |	0 	    | AMP-LOH      |
#' |2+       |	1+ 	    | AMP          |
#' |2+       |	NA 	    | AMP-[LOH?]   |
#' |---------|----------|--------------|
#' @param controlfreec.df input filename with CNV segments,
#'        filterLowUncerntainty if set to TRUE segments with uncertainty equal to -1 will be discarded
#'        pvalThreshold  threshold of pvalues to filter if the pvalues are included in the file
#' @return A GRanges object with the segments predicted by ControlFreec
#' @export
parseCfreec=function(controlfreec.df,
                     filterLowUncertainty=TRUE,
                     pvalThreshold=0.01){

  controlfreec.gr=GenomicRanges::makeGRangesFromDataFrame( controlfreec.df,
                                       keep.extra.columns = TRUE,
                                       ignore.strand = TRUE)%>%
    GenomeInfoDb::sortSeqlevels( ) %>%
    BiocGenerics::sort()

  GenomeInfoDb::seqlevelsStyle( controlfreec.gr)='UCSC'

  mcols_new=S4Vectors::mcols( controlfreec.gr ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate( total.allele.copies=as.numeric(copy.number),
                   major.allele.copies=stringr::str_count( genotype, 'A'),
                   minor.allele.copies=stringr::str_count( genotype, 'B'),
                   uncertainty=as.numeric(uncertainty)
                   )
  flags=apply(mcols_new, 1, function(K){ cnvFlag(total.cn = K['total.allele.copies'], minor.cn = K['minor.allele.copies'] )}) # pass the total.cn to make sure that cases with uncertainty=-1 are parsed properly
  mcols_new = mcols_new %>%
    dplyr::mutate( cnv.flag=flags)
  S4Vectors::mcols( controlfreec.gr)=mcols_new
  if( filterLowUncertainty==TRUE){
    keep=which(controlfreec.gr$uncertainty >-1)
    controlfreec.gr=controlfreec.gr[keep]
  }
  if( "WilcoxonRankSumTestPvalue" %in% colnames( S4Vectors::mcols(controlfreec.gr))){
    keep=which( controlfreec.gr$WilcoxonRankSumTestPvalue< pvalThreshold &&	controlfreec.gr$KolmogorovSmirnovPvalue<pvalThreshold)
    controlfreec.gr=controlfreec.gr[keep]
  }

  return(controlfreec.gr)
}



#' CloneCNA claims that can efficiently and accurately identify somatic copy number alterations from heterogeneous tumor samples. (https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-016-1174-7)
#' CloneCNA can detect teh cellularity of each abberation, and from that extract the subclonal abundance. This comes in the column Cellularity.
#' When Cellularity is 0 it indicates normal
#' Presumably, segments with different values in that column correspond to different clones. As a result we can tag different clones based on these frequencies.
#' @param clonecna.fn input filename with CNV segments,
#' @return A GRanges object with the segments predicted by CloneCNA
#' @export
parseCloneCNA_file=function(
  clonecna.fn
){
  skip=grep('Chr', readLines(clonecna.fn)) -1
  clonecna=read.table( clonecna.fn,header=TRUE , skip=skip ,sep="\t")
  # keep only the ones that are not normal

  return( parseCloneCNA( clonecna.gr ) )
}


#' Generate a cnv Granges from a dataframe created by ControlFreec (file ending in .CNVs or contains pvalues.)
#' CloneCNA claims that can efficiently and accurately identify somatic copy number alterations from
#' heterogeneous tumor samples. (https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-016-1174-7)
#' CloneCNA can detect teh cellularity of each abberation, and from that extract the subclonal abundance. T
#' his comes in the column Cellularity.
#' When Cellularity is 0 it indicates normal
#' Presumably, segments with different values in that column correspond to different clones. As a result we can tag different clones based on these frequencies.
#' The column Abberation describes the type of abberation:
#' |---------|----------|--------------|
#' |total cn | minor cn |	type         |
#' |---------|----------|--------------|
#' |0        |	0 	    | HOMDEL       |
#' |0        |	NA 	    | HOMDEL       |
#' |1        |	0 	    | HETDEL       |
#' |1        |	NA 	    | HETDEL       |
#' |2        |	0 	    | NEUT-LOH      |
#' |2        |	1 	    | NEUT         |
#' |2        |	NA 	    | NEUT/Unknown |
#' |2+       |	0 	    | AMP-LOH      |
#' |2+       |	1+ 	    | AMP          |
#' |2+       |	NA 	    | AMP-[LOH?]   |
#' |---------|----------|--------------|
#'   SInce we load only the clonal information only CNV abberations are stored in the objects.
#' @param clonecna.fn input filename with CNV segments,
#' @return A GRanges object with the segments predicted by CloneCNA
#' @export
parseCloneCNA=function(
  clonecna.df
){
  clonecna.gr=GenomicRanges::makeGRangesFromDataFrame( clonecna.df,
                                           keep.extra.columns = TRUE,
                                           ignore.strand = TRUE,
                                           start.field = 'StartPos',
                                           end.field = 'EndPos')%>%
    GenomeInfoDb::sortSeqlevels( ) %>%
    BiocGenerics::sort()
  GenomeInfoDb::seqlevelsStyle(clonecna.gr)='UCSC'

  #get the info from the file
  mcols_new=S4Vectors::mcols( clonecna.gr ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate( total.allele.copies=CN,
                   major.allele.copies=mCN,
                   minor.allele.copies=CN-mCN)

  flags=apply(mcols_new, 1, function(K){ cnvFlag(total.cn = K['total.allele.copies'], minor.cn = K['minor.allele.copies'] )}) # pass the total.cn to make sure that cases with uncertainty=-1 are parsed properly
  mcols_new = mcols_new %>%
    dplyr::mutate( cnv.flag=flags)
  S4Vectors::mcols( clonecna.gr)=mcols_new
  return( clonecna.gr )
}





#' get the flag for a CNV,
#' according to the table
#' |---------|----------|--------------|---------------------------------------------------------------------|
#' |total cn | minor cn |	type         | meaning of type                                                     |
#' |---------|----------|--------------|---------------------------------------------------------------------|
#' |0        |	0 	    | HOMDEL       | Homozygous deletion                                                 |
#' |0        |	NA 	    | HOMDEL       | Homozygous deletion                                                 |
#' |1        |	0 	    | HETDEL       | Heterozygous deletion (1 out of 2 alleles)                          |
#' |1        |	NA 	    | HETDEL       | Heterozygous deletion (this is an edge case that should not occur)  |
#' |2        |	0 	    | NEUTLOH      | Loss of heterozygosity without change in the number of alleles      |
#' |2        |	1 	    | NEUT         | Normal                                                              |
#' |2        |	NA 	    | NEUT/Unknown | Normal or undetermined by the algorithm                             |
#' |2+       |	0 	    | AMP-LOH      | Amplification with loss of heterozygosity                           |
#' |2+       |	1+ 	    | AMP          | Amplification                                                       |
#' |2+       |	NA 	    | AMP-[LOH?]   | Amplification with (possible) loss of heterozygosity                |
#' |---------|----------|--------------|---------------------------------------------------------------------|
cnvFlag=function(major.cn=NA, minor.cn=0, total.cn=NA){
  #message(major.cn, " ", class(major.cn)," " ,minor.cn," ",class(minor.cn), " " , total.cn)
  if(is.na( total.cn ) & is.na(major.cn)){
    stop("Please provide either the total number of alleles or the major allele copies")
  }
  major.cn=as.numeric(major.cn)
  minor.cn=as.numeric(minor.cn)
  total.cn=as.numeric(total.cn)
  if(is.na(total.cn)){
    total.cn=ifelse( is.na(minor.cn), major.cn, major.cn + minor.cn)
  }

  flag="UNKNOWN"
  # set the flag
  if( total.cn == 0 & (minor.cn ==0 | is.na(minor.cn))){ flag="HOMDEL"}
  if( total.cn == 1 & (minor.cn ==0 | is.na(minor.cn))){ flag="HETDEL"}
  if( total.cn == 2 & (!is.na(minor.cn) & minor.cn ==0 )){ flag="NEUT-LOH"}
  if( total.cn == 2 & (!is.na(minor.cn) & minor.cn ==1 )){ flag="NEUT"}
  if( total.cn == 2 & is.na(minor.cn) ){ flag="NEUT/UNKNOWN"}
  if( total.cn >  2 & (!is.na(minor.cn) & minor.cn ==0 )){ flag="AMPLOH"}
  if( total.cn >  2 & (!is.na(minor.cn) & minor.cn >= 1 )){ flag="AMP"}
  if( total.cn >  2 & is.na(minor.cn)  ){ flag="AMP/LOH"}

  return( flag )

}
